// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v5.29.3
// source: common/proto/orderer.proto

package proto

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	OrdererService_SubmitTransaction_FullMethodName   = "/orderer.OrdererService/SubmitTransaction"
	OrdererService_GetBlock_FullMethodName            = "/orderer.OrdererService/GetBlock"
	OrdererService_CreateChannel_FullMethodName       = "/orderer.OrdererService/CreateChannel"
	OrdererService_BroadcastBlock_FullMethodName      = "/orderer.OrdererService/BroadcastBlock"
	OrdererService_GetChannelInfo_FullMethodName      = "/orderer.OrdererService/GetChannelInfo"
	OrdererService_BroadcastToChannel_FullMethodName  = "/orderer.OrdererService/BroadcastToChannel"
	OrdererService_StreamBlocks_FullMethodName        = "/orderer.OrdererService/StreamBlocks"
	OrdererService_GetBlockRange_FullMethodName       = "/orderer.OrdererService/GetBlockRange"
	OrdererService_GetOrdererStatus_FullMethodName    = "/orderer.OrdererService/GetOrdererStatus"
	OrdererService_UpdateChannelConfig_FullMethodName = "/orderer.OrdererService/UpdateChannelConfig"
)

// OrdererServiceClient is the client API for OrdererService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// OrdererService handles transaction ordering and block creation
type OrdererServiceClient interface {
	SubmitTransaction(ctx context.Context, in *Transaction, opts ...grpc.CallOption) (*TransactionResponse, error)
	GetBlock(ctx context.Context, in *BlockRequest, opts ...grpc.CallOption) (*Block, error)
	CreateChannel(ctx context.Context, in *ChannelRequest, opts ...grpc.CallOption) (*ChannelResponse, error)
	BroadcastBlock(ctx context.Context, in *BroadcastRequest, opts ...grpc.CallOption) (*BroadcastResponse, error)
	GetChannelInfo(ctx context.Context, in *ChannelInfoRequest, opts ...grpc.CallOption) (*ChannelInfoResponse, error)
	// Enhanced block broadcasting methods
	BroadcastToChannel(ctx context.Context, in *ChannelBroadcastRequest, opts ...grpc.CallOption) (*ChannelBroadcastResponse, error)
	StreamBlocks(ctx context.Context, in *BlockStreamRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[Block], error)
	GetBlockRange(ctx context.Context, in *BlockRangeRequest, opts ...grpc.CallOption) (*BlockRangeResponse, error)
	GetOrdererStatus(ctx context.Context, in *OrdererStatusRequest, opts ...grpc.CallOption) (*OrdererStatusResponse, error)
	UpdateChannelConfig(ctx context.Context, in *ChannelConfigUpdateRequest, opts ...grpc.CallOption) (*ChannelConfigUpdateResponse, error)
}

type ordererServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewOrdererServiceClient(cc grpc.ClientConnInterface) OrdererServiceClient {
	return &ordererServiceClient{cc}
}

func (c *ordererServiceClient) SubmitTransaction(ctx context.Context, in *Transaction, opts ...grpc.CallOption) (*TransactionResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(TransactionResponse)
	err := c.cc.Invoke(ctx, OrdererService_SubmitTransaction_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ordererServiceClient) GetBlock(ctx context.Context, in *BlockRequest, opts ...grpc.CallOption) (*Block, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Block)
	err := c.cc.Invoke(ctx, OrdererService_GetBlock_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ordererServiceClient) CreateChannel(ctx context.Context, in *ChannelRequest, opts ...grpc.CallOption) (*ChannelResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ChannelResponse)
	err := c.cc.Invoke(ctx, OrdererService_CreateChannel_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ordererServiceClient) BroadcastBlock(ctx context.Context, in *BroadcastRequest, opts ...grpc.CallOption) (*BroadcastResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BroadcastResponse)
	err := c.cc.Invoke(ctx, OrdererService_BroadcastBlock_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ordererServiceClient) GetChannelInfo(ctx context.Context, in *ChannelInfoRequest, opts ...grpc.CallOption) (*ChannelInfoResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ChannelInfoResponse)
	err := c.cc.Invoke(ctx, OrdererService_GetChannelInfo_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ordererServiceClient) BroadcastToChannel(ctx context.Context, in *ChannelBroadcastRequest, opts ...grpc.CallOption) (*ChannelBroadcastResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ChannelBroadcastResponse)
	err := c.cc.Invoke(ctx, OrdererService_BroadcastToChannel_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ordererServiceClient) StreamBlocks(ctx context.Context, in *BlockStreamRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[Block], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &OrdererService_ServiceDesc.Streams[0], OrdererService_StreamBlocks_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[BlockStreamRequest, Block]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type OrdererService_StreamBlocksClient = grpc.ServerStreamingClient[Block]

func (c *ordererServiceClient) GetBlockRange(ctx context.Context, in *BlockRangeRequest, opts ...grpc.CallOption) (*BlockRangeResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BlockRangeResponse)
	err := c.cc.Invoke(ctx, OrdererService_GetBlockRange_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ordererServiceClient) GetOrdererStatus(ctx context.Context, in *OrdererStatusRequest, opts ...grpc.CallOption) (*OrdererStatusResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(OrdererStatusResponse)
	err := c.cc.Invoke(ctx, OrdererService_GetOrdererStatus_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ordererServiceClient) UpdateChannelConfig(ctx context.Context, in *ChannelConfigUpdateRequest, opts ...grpc.CallOption) (*ChannelConfigUpdateResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ChannelConfigUpdateResponse)
	err := c.cc.Invoke(ctx, OrdererService_UpdateChannelConfig_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// OrdererServiceServer is the server API for OrdererService service.
// All implementations must embed UnimplementedOrdererServiceServer
// for forward compatibility.
//
// OrdererService handles transaction ordering and block creation
type OrdererServiceServer interface {
	SubmitTransaction(context.Context, *Transaction) (*TransactionResponse, error)
	GetBlock(context.Context, *BlockRequest) (*Block, error)
	CreateChannel(context.Context, *ChannelRequest) (*ChannelResponse, error)
	BroadcastBlock(context.Context, *BroadcastRequest) (*BroadcastResponse, error)
	GetChannelInfo(context.Context, *ChannelInfoRequest) (*ChannelInfoResponse, error)
	// Enhanced block broadcasting methods
	BroadcastToChannel(context.Context, *ChannelBroadcastRequest) (*ChannelBroadcastResponse, error)
	StreamBlocks(*BlockStreamRequest, grpc.ServerStreamingServer[Block]) error
	GetBlockRange(context.Context, *BlockRangeRequest) (*BlockRangeResponse, error)
	GetOrdererStatus(context.Context, *OrdererStatusRequest) (*OrdererStatusResponse, error)
	UpdateChannelConfig(context.Context, *ChannelConfigUpdateRequest) (*ChannelConfigUpdateResponse, error)
	mustEmbedUnimplementedOrdererServiceServer()
}

// UnimplementedOrdererServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedOrdererServiceServer struct{}

func (UnimplementedOrdererServiceServer) SubmitTransaction(context.Context, *Transaction) (*TransactionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SubmitTransaction not implemented")
}
func (UnimplementedOrdererServiceServer) GetBlock(context.Context, *BlockRequest) (*Block, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetBlock not implemented")
}
func (UnimplementedOrdererServiceServer) CreateChannel(context.Context, *ChannelRequest) (*ChannelResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateChannel not implemented")
}
func (UnimplementedOrdererServiceServer) BroadcastBlock(context.Context, *BroadcastRequest) (*BroadcastResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BroadcastBlock not implemented")
}
func (UnimplementedOrdererServiceServer) GetChannelInfo(context.Context, *ChannelInfoRequest) (*ChannelInfoResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetChannelInfo not implemented")
}
func (UnimplementedOrdererServiceServer) BroadcastToChannel(context.Context, *ChannelBroadcastRequest) (*ChannelBroadcastResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BroadcastToChannel not implemented")
}
func (UnimplementedOrdererServiceServer) StreamBlocks(*BlockStreamRequest, grpc.ServerStreamingServer[Block]) error {
	return status.Errorf(codes.Unimplemented, "method StreamBlocks not implemented")
}
func (UnimplementedOrdererServiceServer) GetBlockRange(context.Context, *BlockRangeRequest) (*BlockRangeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetBlockRange not implemented")
}
func (UnimplementedOrdererServiceServer) GetOrdererStatus(context.Context, *OrdererStatusRequest) (*OrdererStatusResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetOrdererStatus not implemented")
}
func (UnimplementedOrdererServiceServer) UpdateChannelConfig(context.Context, *ChannelConfigUpdateRequest) (*ChannelConfigUpdateResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateChannelConfig not implemented")
}
func (UnimplementedOrdererServiceServer) mustEmbedUnimplementedOrdererServiceServer() {}
func (UnimplementedOrdererServiceServer) testEmbeddedByValue()                        {}

// UnsafeOrdererServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to OrdererServiceServer will
// result in compilation errors.
type UnsafeOrdererServiceServer interface {
	mustEmbedUnimplementedOrdererServiceServer()
}

func RegisterOrdererServiceServer(s grpc.ServiceRegistrar, srv OrdererServiceServer) {
	// If the following call pancis, it indicates UnimplementedOrdererServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&OrdererService_ServiceDesc, srv)
}

func _OrdererService_SubmitTransaction_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Transaction)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OrdererServiceServer).SubmitTransaction(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: OrdererService_SubmitTransaction_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OrdererServiceServer).SubmitTransaction(ctx, req.(*Transaction))
	}
	return interceptor(ctx, in, info, handler)
}

func _OrdererService_GetBlock_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BlockRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OrdererServiceServer).GetBlock(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: OrdererService_GetBlock_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OrdererServiceServer).GetBlock(ctx, req.(*BlockRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _OrdererService_CreateChannel_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ChannelRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OrdererServiceServer).CreateChannel(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: OrdererService_CreateChannel_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OrdererServiceServer).CreateChannel(ctx, req.(*ChannelRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _OrdererService_BroadcastBlock_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BroadcastRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OrdererServiceServer).BroadcastBlock(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: OrdererService_BroadcastBlock_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OrdererServiceServer).BroadcastBlock(ctx, req.(*BroadcastRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _OrdererService_GetChannelInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ChannelInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OrdererServiceServer).GetChannelInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: OrdererService_GetChannelInfo_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OrdererServiceServer).GetChannelInfo(ctx, req.(*ChannelInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _OrdererService_BroadcastToChannel_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ChannelBroadcastRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OrdererServiceServer).BroadcastToChannel(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: OrdererService_BroadcastToChannel_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OrdererServiceServer).BroadcastToChannel(ctx, req.(*ChannelBroadcastRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _OrdererService_StreamBlocks_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(BlockStreamRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(OrdererServiceServer).StreamBlocks(m, &grpc.GenericServerStream[BlockStreamRequest, Block]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type OrdererService_StreamBlocksServer = grpc.ServerStreamingServer[Block]

func _OrdererService_GetBlockRange_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BlockRangeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OrdererServiceServer).GetBlockRange(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: OrdererService_GetBlockRange_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OrdererServiceServer).GetBlockRange(ctx, req.(*BlockRangeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _OrdererService_GetOrdererStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(OrdererStatusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OrdererServiceServer).GetOrdererStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: OrdererService_GetOrdererStatus_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OrdererServiceServer).GetOrdererStatus(ctx, req.(*OrdererStatusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _OrdererService_UpdateChannelConfig_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ChannelConfigUpdateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OrdererServiceServer).UpdateChannelConfig(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: OrdererService_UpdateChannelConfig_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OrdererServiceServer).UpdateChannelConfig(ctx, req.(*ChannelConfigUpdateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// OrdererService_ServiceDesc is the grpc.ServiceDesc for OrdererService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var OrdererService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "orderer.OrdererService",
	HandlerType: (*OrdererServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "SubmitTransaction",
			Handler:    _OrdererService_SubmitTransaction_Handler,
		},
		{
			MethodName: "GetBlock",
			Handler:    _OrdererService_GetBlock_Handler,
		},
		{
			MethodName: "CreateChannel",
			Handler:    _OrdererService_CreateChannel_Handler,
		},
		{
			MethodName: "BroadcastBlock",
			Handler:    _OrdererService_BroadcastBlock_Handler,
		},
		{
			MethodName: "GetChannelInfo",
			Handler:    _OrdererService_GetChannelInfo_Handler,
		},
		{
			MethodName: "BroadcastToChannel",
			Handler:    _OrdererService_BroadcastToChannel_Handler,
		},
		{
			MethodName: "GetBlockRange",
			Handler:    _OrdererService_GetBlockRange_Handler,
		},
		{
			MethodName: "GetOrdererStatus",
			Handler:    _OrdererService_GetOrdererStatus_Handler,
		},
		{
			MethodName: "UpdateChannelConfig",
			Handler:    _OrdererService_UpdateChannelConfig_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "StreamBlocks",
			Handler:       _OrdererService_StreamBlocks_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "common/proto/orderer.proto",
}

const (
	PeerService_ProcessBlock_FullMethodName         = "/orderer.PeerService/ProcessBlock"
	PeerService_EndorseTransaction_FullMethodName   = "/orderer.PeerService/EndorseTransaction"
	PeerService_ValidateTransaction_FullMethodName  = "/orderer.PeerService/ValidateTransaction"
	PeerService_JoinChannel_FullMethodName          = "/orderer.PeerService/JoinChannel"
	PeerService_QueryLedger_FullMethodName          = "/orderer.PeerService/QueryLedger"
	PeerService_GetPeerInfo_FullMethodName          = "/orderer.PeerService/GetPeerInfo"
	PeerService_SyncBlocks_FullMethodName           = "/orderer.PeerService/SyncBlocks"
	PeerService_NotifyBlockCommit_FullMethodName    = "/orderer.PeerService/NotifyBlockCommit"
	PeerService_GetChannelHeight_FullMethodName     = "/orderer.PeerService/GetChannelHeight"
	PeerService_ValidateEndorsement_FullMethodName  = "/orderer.PeerService/ValidateEndorsement"
	PeerService_GetTransactionStatus_FullMethodName = "/orderer.PeerService/GetTransactionStatus"
	PeerService_LeaveChannel_FullMethodName         = "/orderer.PeerService/LeaveChannel"
	PeerService_HealthCheck_FullMethodName          = "/orderer.PeerService/HealthCheck"
)

// PeerServiceClient is the client API for PeerService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// PeerService handles transaction endorsement and validation
type PeerServiceClient interface {
	ProcessBlock(ctx context.Context, in *Block, opts ...grpc.CallOption) (*ProcessBlockResponse, error)
	EndorseTransaction(ctx context.Context, in *TransactionProposal, opts ...grpc.CallOption) (*EndorsementResponse, error)
	ValidateTransaction(ctx context.Context, in *ValidationRequest, opts ...grpc.CallOption) (*ValidationResponse, error)
	JoinChannel(ctx context.Context, in *JoinChannelRequest, opts ...grpc.CallOption) (*JoinChannelResponse, error)
	QueryLedger(ctx context.Context, in *LedgerQuery, opts ...grpc.CallOption) (*LedgerQueryResponse, error)
	GetPeerInfo(ctx context.Context, in *PeerInfoRequest, opts ...grpc.CallOption) (*PeerInfoResponse, error)
	// Enhanced peer communication methods
	SyncBlocks(ctx context.Context, in *BlockSyncRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[Block], error)
	NotifyBlockCommit(ctx context.Context, in *BlockCommitNotification, opts ...grpc.CallOption) (*BlockCommitResponse, error)
	GetChannelHeight(ctx context.Context, in *ChannelHeightRequest, opts ...grpc.CallOption) (*ChannelHeightResponse, error)
	ValidateEndorsement(ctx context.Context, in *EndorsementValidationRequest, opts ...grpc.CallOption) (*EndorsementValidationResponse, error)
	GetTransactionStatus(ctx context.Context, in *TransactionStatusRequest, opts ...grpc.CallOption) (*TransactionStatusResponse, error)
	LeaveChannel(ctx context.Context, in *LeaveChannelRequest, opts ...grpc.CallOption) (*LeaveChannelResponse, error)
	HealthCheck(ctx context.Context, in *HealthCheckRequest, opts ...grpc.CallOption) (*HealthCheckResponse, error)
}

type peerServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewPeerServiceClient(cc grpc.ClientConnInterface) PeerServiceClient {
	return &peerServiceClient{cc}
}

func (c *peerServiceClient) ProcessBlock(ctx context.Context, in *Block, opts ...grpc.CallOption) (*ProcessBlockResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ProcessBlockResponse)
	err := c.cc.Invoke(ctx, PeerService_ProcessBlock_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *peerServiceClient) EndorseTransaction(ctx context.Context, in *TransactionProposal, opts ...grpc.CallOption) (*EndorsementResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(EndorsementResponse)
	err := c.cc.Invoke(ctx, PeerService_EndorseTransaction_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *peerServiceClient) ValidateTransaction(ctx context.Context, in *ValidationRequest, opts ...grpc.CallOption) (*ValidationResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ValidationResponse)
	err := c.cc.Invoke(ctx, PeerService_ValidateTransaction_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *peerServiceClient) JoinChannel(ctx context.Context, in *JoinChannelRequest, opts ...grpc.CallOption) (*JoinChannelResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(JoinChannelResponse)
	err := c.cc.Invoke(ctx, PeerService_JoinChannel_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *peerServiceClient) QueryLedger(ctx context.Context, in *LedgerQuery, opts ...grpc.CallOption) (*LedgerQueryResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(LedgerQueryResponse)
	err := c.cc.Invoke(ctx, PeerService_QueryLedger_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *peerServiceClient) GetPeerInfo(ctx context.Context, in *PeerInfoRequest, opts ...grpc.CallOption) (*PeerInfoResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(PeerInfoResponse)
	err := c.cc.Invoke(ctx, PeerService_GetPeerInfo_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *peerServiceClient) SyncBlocks(ctx context.Context, in *BlockSyncRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[Block], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &PeerService_ServiceDesc.Streams[0], PeerService_SyncBlocks_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[BlockSyncRequest, Block]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type PeerService_SyncBlocksClient = grpc.ServerStreamingClient[Block]

func (c *peerServiceClient) NotifyBlockCommit(ctx context.Context, in *BlockCommitNotification, opts ...grpc.CallOption) (*BlockCommitResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BlockCommitResponse)
	err := c.cc.Invoke(ctx, PeerService_NotifyBlockCommit_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *peerServiceClient) GetChannelHeight(ctx context.Context, in *ChannelHeightRequest, opts ...grpc.CallOption) (*ChannelHeightResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ChannelHeightResponse)
	err := c.cc.Invoke(ctx, PeerService_GetChannelHeight_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *peerServiceClient) ValidateEndorsement(ctx context.Context, in *EndorsementValidationRequest, opts ...grpc.CallOption) (*EndorsementValidationResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(EndorsementValidationResponse)
	err := c.cc.Invoke(ctx, PeerService_ValidateEndorsement_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *peerServiceClient) GetTransactionStatus(ctx context.Context, in *TransactionStatusRequest, opts ...grpc.CallOption) (*TransactionStatusResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(TransactionStatusResponse)
	err := c.cc.Invoke(ctx, PeerService_GetTransactionStatus_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *peerServiceClient) LeaveChannel(ctx context.Context, in *LeaveChannelRequest, opts ...grpc.CallOption) (*LeaveChannelResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(LeaveChannelResponse)
	err := c.cc.Invoke(ctx, PeerService_LeaveChannel_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *peerServiceClient) HealthCheck(ctx context.Context, in *HealthCheckRequest, opts ...grpc.CallOption) (*HealthCheckResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(HealthCheckResponse)
	err := c.cc.Invoke(ctx, PeerService_HealthCheck_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// PeerServiceServer is the server API for PeerService service.
// All implementations must embed UnimplementedPeerServiceServer
// for forward compatibility.
//
// PeerService handles transaction endorsement and validation
type PeerServiceServer interface {
	ProcessBlock(context.Context, *Block) (*ProcessBlockResponse, error)
	EndorseTransaction(context.Context, *TransactionProposal) (*EndorsementResponse, error)
	ValidateTransaction(context.Context, *ValidationRequest) (*ValidationResponse, error)
	JoinChannel(context.Context, *JoinChannelRequest) (*JoinChannelResponse, error)
	QueryLedger(context.Context, *LedgerQuery) (*LedgerQueryResponse, error)
	GetPeerInfo(context.Context, *PeerInfoRequest) (*PeerInfoResponse, error)
	// Enhanced peer communication methods
	SyncBlocks(*BlockSyncRequest, grpc.ServerStreamingServer[Block]) error
	NotifyBlockCommit(context.Context, *BlockCommitNotification) (*BlockCommitResponse, error)
	GetChannelHeight(context.Context, *ChannelHeightRequest) (*ChannelHeightResponse, error)
	ValidateEndorsement(context.Context, *EndorsementValidationRequest) (*EndorsementValidationResponse, error)
	GetTransactionStatus(context.Context, *TransactionStatusRequest) (*TransactionStatusResponse, error)
	LeaveChannel(context.Context, *LeaveChannelRequest) (*LeaveChannelResponse, error)
	HealthCheck(context.Context, *HealthCheckRequest) (*HealthCheckResponse, error)
	mustEmbedUnimplementedPeerServiceServer()
}

// UnimplementedPeerServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedPeerServiceServer struct{}

func (UnimplementedPeerServiceServer) ProcessBlock(context.Context, *Block) (*ProcessBlockResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ProcessBlock not implemented")
}
func (UnimplementedPeerServiceServer) EndorseTransaction(context.Context, *TransactionProposal) (*EndorsementResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method EndorseTransaction not implemented")
}
func (UnimplementedPeerServiceServer) ValidateTransaction(context.Context, *ValidationRequest) (*ValidationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ValidateTransaction not implemented")
}
func (UnimplementedPeerServiceServer) JoinChannel(context.Context, *JoinChannelRequest) (*JoinChannelResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method JoinChannel not implemented")
}
func (UnimplementedPeerServiceServer) QueryLedger(context.Context, *LedgerQuery) (*LedgerQueryResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryLedger not implemented")
}
func (UnimplementedPeerServiceServer) GetPeerInfo(context.Context, *PeerInfoRequest) (*PeerInfoResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetPeerInfo not implemented")
}
func (UnimplementedPeerServiceServer) SyncBlocks(*BlockSyncRequest, grpc.ServerStreamingServer[Block]) error {
	return status.Errorf(codes.Unimplemented, "method SyncBlocks not implemented")
}
func (UnimplementedPeerServiceServer) NotifyBlockCommit(context.Context, *BlockCommitNotification) (*BlockCommitResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method NotifyBlockCommit not implemented")
}
func (UnimplementedPeerServiceServer) GetChannelHeight(context.Context, *ChannelHeightRequest) (*ChannelHeightResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetChannelHeight not implemented")
}
func (UnimplementedPeerServiceServer) ValidateEndorsement(context.Context, *EndorsementValidationRequest) (*EndorsementValidationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ValidateEndorsement not implemented")
}
func (UnimplementedPeerServiceServer) GetTransactionStatus(context.Context, *TransactionStatusRequest) (*TransactionStatusResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetTransactionStatus not implemented")
}
func (UnimplementedPeerServiceServer) LeaveChannel(context.Context, *LeaveChannelRequest) (*LeaveChannelResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LeaveChannel not implemented")
}
func (UnimplementedPeerServiceServer) HealthCheck(context.Context, *HealthCheckRequest) (*HealthCheckResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method HealthCheck not implemented")
}
func (UnimplementedPeerServiceServer) mustEmbedUnimplementedPeerServiceServer() {}
func (UnimplementedPeerServiceServer) testEmbeddedByValue()                     {}

// UnsafePeerServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to PeerServiceServer will
// result in compilation errors.
type UnsafePeerServiceServer interface {
	mustEmbedUnimplementedPeerServiceServer()
}

func RegisterPeerServiceServer(s grpc.ServiceRegistrar, srv PeerServiceServer) {
	// If the following call pancis, it indicates UnimplementedPeerServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&PeerService_ServiceDesc, srv)
}

func _PeerService_ProcessBlock_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Block)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PeerServiceServer).ProcessBlock(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PeerService_ProcessBlock_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PeerServiceServer).ProcessBlock(ctx, req.(*Block))
	}
	return interceptor(ctx, in, info, handler)
}

func _PeerService_EndorseTransaction_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TransactionProposal)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PeerServiceServer).EndorseTransaction(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PeerService_EndorseTransaction_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PeerServiceServer).EndorseTransaction(ctx, req.(*TransactionProposal))
	}
	return interceptor(ctx, in, info, handler)
}

func _PeerService_ValidateTransaction_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ValidationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PeerServiceServer).ValidateTransaction(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PeerService_ValidateTransaction_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PeerServiceServer).ValidateTransaction(ctx, req.(*ValidationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PeerService_JoinChannel_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(JoinChannelRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PeerServiceServer).JoinChannel(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PeerService_JoinChannel_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PeerServiceServer).JoinChannel(ctx, req.(*JoinChannelRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PeerService_QueryLedger_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LedgerQuery)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PeerServiceServer).QueryLedger(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PeerService_QueryLedger_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PeerServiceServer).QueryLedger(ctx, req.(*LedgerQuery))
	}
	return interceptor(ctx, in, info, handler)
}

func _PeerService_GetPeerInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PeerInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PeerServiceServer).GetPeerInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PeerService_GetPeerInfo_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PeerServiceServer).GetPeerInfo(ctx, req.(*PeerInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PeerService_SyncBlocks_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(BlockSyncRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(PeerServiceServer).SyncBlocks(m, &grpc.GenericServerStream[BlockSyncRequest, Block]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type PeerService_SyncBlocksServer = grpc.ServerStreamingServer[Block]

func _PeerService_NotifyBlockCommit_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BlockCommitNotification)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PeerServiceServer).NotifyBlockCommit(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PeerService_NotifyBlockCommit_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PeerServiceServer).NotifyBlockCommit(ctx, req.(*BlockCommitNotification))
	}
	return interceptor(ctx, in, info, handler)
}

func _PeerService_GetChannelHeight_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ChannelHeightRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PeerServiceServer).GetChannelHeight(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PeerService_GetChannelHeight_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PeerServiceServer).GetChannelHeight(ctx, req.(*ChannelHeightRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PeerService_ValidateEndorsement_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EndorsementValidationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PeerServiceServer).ValidateEndorsement(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PeerService_ValidateEndorsement_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PeerServiceServer).ValidateEndorsement(ctx, req.(*EndorsementValidationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PeerService_GetTransactionStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TransactionStatusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PeerServiceServer).GetTransactionStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PeerService_GetTransactionStatus_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PeerServiceServer).GetTransactionStatus(ctx, req.(*TransactionStatusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PeerService_LeaveChannel_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LeaveChannelRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PeerServiceServer).LeaveChannel(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PeerService_LeaveChannel_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PeerServiceServer).LeaveChannel(ctx, req.(*LeaveChannelRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PeerService_HealthCheck_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HealthCheckRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PeerServiceServer).HealthCheck(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PeerService_HealthCheck_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PeerServiceServer).HealthCheck(ctx, req.(*HealthCheckRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// PeerService_ServiceDesc is the grpc.ServiceDesc for PeerService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var PeerService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "orderer.PeerService",
	HandlerType: (*PeerServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ProcessBlock",
			Handler:    _PeerService_ProcessBlock_Handler,
		},
		{
			MethodName: "EndorseTransaction",
			Handler:    _PeerService_EndorseTransaction_Handler,
		},
		{
			MethodName: "ValidateTransaction",
			Handler:    _PeerService_ValidateTransaction_Handler,
		},
		{
			MethodName: "JoinChannel",
			Handler:    _PeerService_JoinChannel_Handler,
		},
		{
			MethodName: "QueryLedger",
			Handler:    _PeerService_QueryLedger_Handler,
		},
		{
			MethodName: "GetPeerInfo",
			Handler:    _PeerService_GetPeerInfo_Handler,
		},
		{
			MethodName: "NotifyBlockCommit",
			Handler:    _PeerService_NotifyBlockCommit_Handler,
		},
		{
			MethodName: "GetChannelHeight",
			Handler:    _PeerService_GetChannelHeight_Handler,
		},
		{
			MethodName: "ValidateEndorsement",
			Handler:    _PeerService_ValidateEndorsement_Handler,
		},
		{
			MethodName: "GetTransactionStatus",
			Handler:    _PeerService_GetTransactionStatus_Handler,
		},
		{
			MethodName: "LeaveChannel",
			Handler:    _PeerService_LeaveChannel_Handler,
		},
		{
			MethodName: "HealthCheck",
			Handler:    _PeerService_HealthCheck_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "SyncBlocks",
			Handler:       _PeerService_SyncBlocks_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "common/proto/orderer.proto",
}
